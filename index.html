<!doctype html>
<html lang="zh-CN">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
<title>æ˜Ÿç©ºç²’å­ï¼ˆSafari ç›´æ¥æ‰“å¼€ï¼‰</title>
<style>
  html,body{height:100%;margin:0;background:#071024;font-family:system-ui,-apple-system,Segoe UI,Roboto,"Helvetica Neue",Arial;color:#fff;overflow:hidden}
  #app{width:100%;height:100vh;position:relative;display:block}
  canvas{display:block;width:100%;height:100%}
  .ui{position:absolute;left:10px;top:10px;display:flex;gap:8px;align-items:center;background:rgba(255,255,255,0.04);padding:8px;border-radius:10px;backdrop-filter:blur(6px)}
  .ui select,.ui input[type=color],.ui button{height:36px;border-radius:8px;border:0;padding:6px 8px;background:rgba(255,255,255,0.04);color:#fff}
  #fullscreen{position:absolute;right:12px;top:12px;height:40px;padding:8px;border-radius:8px;background:rgba(255,255,255,0.04);border:0;color:#fff}
  #hint{position:absolute;left:12px;bottom:12px;background:rgba(0,0,0,0.28);padding:8px;border-radius:8px;font-size:13px}
  #cameraToggle{height:36px;border-radius:8px;border:0;padding:6px 8px;background:rgba(255,255,255,0.04);color:#fff;margin-left:6px}
</style>
</head>
<body>
  <div id="app"></div>
  <div class="ui">
    <select id="modelSelect" title="æ¨¡å‹é€‰æ‹©">
      <option value="none">çº¯ç²’å­</option>
      <option value="moon">æœˆçƒ ğŸŒ•</option>
      <option value="saturn">åœŸæ˜Ÿ ğŸª</option>
      <option value="heart">çˆ±å¿ƒ ğŸ’—</option>
      <option value="fireworks">çƒŸèŠ± ğŸ†</option>
    </select>
    <input type="color" id="colorPicker" value="#ffd166" title="ç²’å­é¢œè‰²" />
    <button id="resetBtn">é‡ç½®</button>
    <button id="cameraToggle">æ‰‹åŠ¿: å…³</button>
  </div>
  <button id="fullscreen">å…¨å± â¤¢</button>
  <div id="hint">ç‚¹è§¦ç¼©æ”¾ / åŒæŒ‡æåˆ / å¼€å¯æ‘„åƒå¤´æ‰‹åŠ¿ï¼ˆå…è®¸æ‘„åƒå¤´æƒé™ï¼‰</div>

  <!-- Three.js (CDN) -->
  <script src="https://cdn.jsdelivr.net/npm/three@0.154.0/build/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.154.0/examples/js/controls/OrbitControls.js"></script>
  <!-- MediaPipe Hands (å¯é€‰ï¼Œç”¨äºæ‰‹åŠ¿) -->
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>

  <script>
  // Mobile-first single-file particle scene for Safari
  const app = document.getElementById('app');
  const canvas = document.createElement('canvas');
  app.appendChild(canvas);

  const renderer = new THREE.WebGLRenderer({canvas, antialias:true, alpha:true});
  renderer.setPixelRatio(window.devicePixelRatio || 1);
  renderer.setSize(window.innerWidth, window.innerHeight);

  const scene = new THREE.Scene();
  scene.fog = new THREE.FogExp2(0x071024, 0.002);

  const camera = new THREE.PerspectiveCamera(50, window.innerWidth/window.innerHeight, 0.1, 1000);
  camera.position.set(0,0,70);

  const controls = new THREE.OrbitControls(camera, renderer.domElement);
  controls.enablePan = false;
  controls.enableRotate = true;
  controls.enableDamping = true;
  controls.dampingFactor = 0.08;
  controls.minDistance = 12;
  controls.maxDistance = 300;

  scene.add(new THREE.AmbientLight(0x8888aa, 0.6));
  const light = new THREE.DirectionalLight(0xffffff, 0.6);
  light.position.set(5,10,7); scene.add(light);

  // texture for particle (canvas)
  function makeTex(size=128){
    const c = document.createElement('canvas'); c.width = c.height = size;
    const ctx = c.getContext('2d');
    const g = ctx.createRadialGradient(size/2,size/2,0,size/2,size/2,size/2);
    g.addColorStop(0,'rgba(255,255,255,1)');
    g.addColorStop(0.2,'rgba(255,255,255,0.9)');
    g.addColorStop(0.45,'rgba(255,255,255,0.18)');
    g.addColorStop(1,'rgba(255,255,255,0)');
    ctx.fillStyle = g; ctx.fillRect(0,0,size,size);
    for(let i=0;i<10;i++){ ctx.beginPath(); ctx.fillStyle='rgba(255,255,255,0.9)'; ctx.arc(Math.random()*size,Math.random()*size,Math.random()*2+0.5,0,Math.PI*2); ctx.fill(); }
    return new THREE.CanvasTexture(c);
  }
  const sparkle = makeTex(128);

  let particleSystem, particleMat, particleGeo;
  let particleCount = 9000;

  function createParticles(){
    if(particleSystem){ scene.remove(particleSystem); particleGeo.dispose(); particleMat.dispose(); }
    particleGeo = new THREE.BufferGeometry();
    const pos = new Float32Array(particleCount*3);
    const size = new Float32Array(particleCount);
    for(let i=0;i<particleCount;i++){
      pos[i*3] = THREE.MathUtils.randFloatSpread(180);
      pos[i*3+1] = THREE.MathUtils.randFloatSpread(100);
      pos[i*3+2] = THREE.MathUtils.randFloatSpread(180);
      size[i] = Math.random()*2.6 + 0.6;
    }
    particleGeo.setAttribute('position', new THREE.BufferAttribute(pos,3));
    particleGeo.setAttribute('aSize', new THREE.BufferAttribute(size,1));

    particleMat = new THREE.ShaderMaterial({
      transparent:true,
      depthWrite:false,
      blending:THREE.AdditiveBlending,
      uniforms:{
        uTime:{value:0},
        uColor:{value:new THREE.Color(document.getElementById('colorPicker').value)},
        uTex:{value:sparkle}
      },
      vertexShader: `
        attribute float aSize;
        varying float v;
        uniform float uTime;
        void main(){
          v = 0.6 + 0.4*sin(uTime*2.0 + position.x*0.01 + position.y*0.02);
          vec3 p = position + normalize(position) * 0.5 * v;
          vec4 mv = modelViewMatrix * vec4(p,1.0);
          gl_PointSize = aSize * (150.0 / -mv.z) * (0.7 + 0.6*v);
          gl_Position = projectionMatrix * mv;
        }`,
      fragmentShader: `
        uniform vec3 uColor;
        uniform sampler2D uTex;
        varying float v;
        void main(){
          vec4 t = texture2D(uTex, gl_PointCoord);
          float a = t.a * (0.6 + 0.4*v);
          gl_FragColor = vec4(uColor * t.rgb * (0.7 + v*0.6), a);
        }`
    });

    particleSystem = new THREE.Points(particleGeo, particleMat);
    scene.add(particleSystem);
  }
  createParticles();

  // models group
  const group = new THREE.Group(); scene.add(group);

  function addMoon(){ const geo=new THREE.SphereGeometry(8,48,48); const mat=new THREE.MeshStandardMaterial({color:0xdddddd, roughness:0.9}); const m=new THREE.Mesh(geo,mat); m.position.set(-18,8,-18); group.add(m); }
  function addSaturn(){ const body=new THREE.Mesh(new THREE.SphereGeometry(6,40,40),new THREE.MeshStandardMaterial({color:0xffe6c0})); body.position.set(18,6,-12); const ring=new THREE.Mesh(new THREE.RingGeometry(8.5,13,64), new THREE.MeshStandardMaterial({color:0xbfa87f, side:THREE.DoubleSide})); ring.rotation.x=Math.PI/2.2; ring.position.copy(body.position); group.add(body); group.add(ring); }
  function addHeart(){ const s=new THREE.Shape(); s.moveTo(0,0); s.bezierCurveTo(0,3,-3,3,-3,0); s.bezierCurveTo(-3,-3,0,-2,0,-1); s.bezierCurveTo(0,-2,3,-3,3,0); s.bezierCurveTo(3,3,0,3,0,0); const geo=new THREE.ExtrudeGeometry(s,{depth:1.5,bevelEnabled:true,bevelThickness:0.4}); const m=new THREE.Mesh(geo,new THREE.MeshStandardMaterial({color:0xff6b9a})); m.scale.set(1.5,1.5,1.5); m.position.set(-6,-8,0); m.rotation.x=-0.3; group.add(m); }
  function addFireworks(){ for(let i=0;i<3;i++){ const pg=new THREE.Group(); for(let j=0;j<60;j++){ const p=new THREE.Mesh(new THREE.SphereGeometry(0.8,6,6), new THREE.MeshStandardMaterial({color: new THREE.Color().setHSL(Math.random(),0.8,0.6)})); p.position.set(THREE.MathUtils.randFloatSpread(40), THREE.MathUtils.randFloat(4,30), THREE.MathUtils.randFloatSpread(40)); pg.add(p);} group.add(pg);} }

  // UI elements
  const modelSelect = document.getElementById('modelSelect');
  const colorPicker = document.getElementById('colorPicker');
  const resetBtn = document.getElementById('resetBtn');
  const cameraToggle = document.getElementById('cameraToggle');
  const fullscreen = document.getElementById('fullscreen');

  modelSelect.addEventListener('change', ()=>{
    const v = modelSelect.value;
    while(group.children.length) group.remove(group.children[0]);
    if(v==='moon') addMoon();
    if(v==='saturn') addSaturn();
    if(v==='heart') addHeart();
    if(v==='fireworks') addFireworks();
  });

  colorPicker.addEventListener('input', ()=> { if(particleMat) particleMat.uniforms.uColor.value.set(colorPicker.value); });

  resetBtn.addEventListener('click', ()=> { controls.reset(); camera.position.set(0,0,70); });

  fullscreen.addEventListener('click', ()=> { if(!document.fullscreenElement) document.documentElement.requestFullscreen().catch(()=>{}); else document.exitFullscreen(); });

  // touch pinch and tap zoom
  let lastDist = null;
  renderer.domElement.addEventListener('touchstart', (e)=> {
    if(e.touches.length === 2){ lastDist = Math.hypot(e.touches[0].pageX - e.touches[1].pageX, e.touches[0].pageY - e.touches[1].pageY); }
  });
  renderer.domElement.addEventListener('touchmove', (e)=> {
    if(e.touches.length === 2 && lastDist){
      const d = Math.hypot(e.touches[0].pageX - e.touches[1].pageX, e.touches[0].pageY - e.touches[1].pageY);
      const factor = d / lastDist;
      camera.position.z = THREE.MathUtils.clamp(camera.position.z / factor, controls.minDistance, controls.maxDistance);
      lastDist = d;
    }
  });
  renderer.domElement.addEventListener('touchend', ()=> { lastDist = null; });

  // double-tap to reset
  let lastTap = 0;
  renderer.domElement.addEventListener('pointerup', ()=> {
    const now = Date.now();
    if(now - lastTap < 300){ controls.reset(); camera.position.set(0,0,70); }
    lastTap = now;
  });

  // MediaPipe hands (optional): open/close -> zoom
  let hands=null, cam=null, camActive=false;
  cameraToggle.addEventListener('click', async ()=>{
    if(camActive){
      if(cam){ cam.stop(); cam=null; }
      if(hands){ hands.close(); hands=null; }
      camActive=false; cameraToggle.textContent='æ‰‹åŠ¿: å…³'; return;
    }
    try{
      hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
      hands.setOptions({maxNumHands:1,modelComplexity:0,minDetectionConfidence:0.6,minTrackingConfidence:0.6});
      hands.onResults(onHands);
      const video = document.createElement('video'); video.style.display='none'; document.body.appendChild(video);
      cam = new Camera(video, {onFrame: async ()=> await hands.send({image:video}), width:320, height:240});
      await cam.start();
      camActive=true; cameraToggle.textContent='æ‰‹åŠ¿: å¼€';
    }catch(err){
      alert('æ— æ³•å¯ç”¨æ‘„åƒå¤´æ‰‹åŠ¿ï¼š' + err.message);
    }
  });

  let lastWidth = null;
  function onHands(results){
    if(!results.multiHandLandmarks || results.multiHandLandmarks.length===0) return;
    const lm = results.multiHandLandmarks[0];
    const ix = lm[8].x, iy = lm[8].y, px = lm[20].x, py = lm[20].y;
    const spread = Math.hypot(ix-px, iy-py);
    if(lastWidth !== null){
      const diff = spread - lastWidth;
      camera.position.z = THREE.MathUtils.clamp(camera.position.z - diff * 180, controls.minDistance, controls.maxDistance);
    }
    lastWidth = spread;
  }

  // animate
  const clock = new THREE.Clock();
  function animate(){
    requestAnimationFrame(animate);
    const t = clock.getElapsedTime();
    if(particleMat) particleMat.uniforms.uTime.value = t;
    if(particleSystem) particleSystem.rotation.y += 0.0006;
    group.rotation.y += 0.0005;
    controls.update();
    renderer.render(scene, camera);
  }
  animate();

  // resize
  window.addEventListener('resize', ()=> {
    camera.aspect = window.innerWidth/window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
  });
  </script>
</body>
</html>
